# 애플리케이션계층2

## 복습

- transport 계층에서 application 계층으로 서비스 해주는 기능이 2가지있다. 그것은 `Multiplexing`과 `에러체킹`이다.
    - `Multiplexing` : TCP와 UDP 두개의 Multiplexing 방식은 다르지만 통신에 필요한 소켓끼리 연결을 해준다.
    - `에러체킹` : transport layer에서 application layer 보낼때 에러가 있었다면 안보낸다.

## Reliable한 데이터 통신 원칙

`Transport`계층으로 부터 아래의 `Network`, `Link`, `Physical` 계층들은 `Reliable하지 않다`. 

reliable하지 않게 하는 이유는 아래 두가지 이다. 

- 패킷 에러가 발생하거나
- 패킷을 유실하거나

## Reliable한 데이터 통신 디자인해보자

**언더라인 : Transport 하위 계층**

## 언더라인에서 에러가 발생할 수 있는 환경이라면 상대방이 에러없이 메세지를 받게 하는 방법

- 보낸 패킷에 checksum을 통해서 에러가 발생했는지 판단한다.
- 상대방이 패킷을 받았는데 패킷에 에러가 있었다면, 못받았다. 없었다면, 받았다. 이렇게 피드백을 전달해 주어야한다.
- 보내니가 에러 피드백을 전달받으면 다시 패킷을 보낸다.

정리를 하자면 3가지가 필요함을 알 수 있다. 

- `에러 체킹`
- `피드백`
- `재전송`

## 시퀀스의 등장

피드백에도 에러가 발생할 수 있기 때문에 시퀀스 넘버를 `모든 패킷`에 붙여야 하고 sender는 피드백 에러가 발생 했다면, 어떤 상황인지 감이 안잡히기 떄문에 재전송하게 된다. 그리고 시퀀스 넘버를 통해서 `중복된 패킷` 전달을 방지할 수 있다. 

### 시퀀스 넘버는 무한대일까?

시퀀스 넘버는 패킷 헤더에 저장된다. 만약 시퀀스 넘버가 무한대(자연수)라면, 실질적 필요한 data보다 더 용량이 커질 수 있다. 즉, `오버헤드`가 일어나는것이다. 

따라서 위와 같은 1개씩 패킷을 보내는 통신은 0과 1 만으로 시퀀스 넘버를 식별할 수 있다. 

## 예시

<img width="458" alt="스크린샷 2023-03-23 오후 8 43 42" src="https://user-images.githubusercontent.com/104377048/227193528-9856fef9-fac2-4709-839a-b9a8c02254ac.png">

1. 그림을 보자 sender가 패킷을 보냈다. 
2. receiver는 시퀀스 0번 패킷을 받고 피드백을 전달했다. 하지만 피드백에 에러가 발생하여 sender는 받았는지 못받았는지 모른다. 
3. sender는 다시 동일한 0번 패킷을 보낸다. 
4. receiver는 동일한 시퀀스 넘버를 가진 패킷임을 확인하고 0번 패킷을 버린다. 다시 피드백을 전달한다. 
5. sender는 1번 패킷을 전달한다. 

## 언더라인에서 에러뿐만 아니라 메세지 유실까지 가능한 환경이라면 상대방이 에러없이 메세지를 받게 하는 방법

타이머 즉, 정해진 시간안에 피드백이 전달되지 않는다면, 재전송을 하는 방법이 있다. 하지만, 이방법도 문제점 2가지가 존재한다. 

1. `타이머의 시간이 짧을때`
2. `타이머의 시간이 길때`

1번부터 확인해보자 시간이 너무 짧다면, 통신하는 곳이 너무 멀어서 메세지가 유실되지도 않았는데, 타이머의 시간이 끝나 다시 재전송을 하게 된다면, `네트워크 오버헤드`가 커지게 된다. 

2번 같은 경우는 타이머의 시간이 길기 때문에 실제로 메세지 유실이 발생했을때 메세지 유실을 확인하고 재전송하기 까지의 시간이 너무 늦어진다. 

## 정리 및 다음시간 예고

오늘은 `패킷 하나씩만 통신`을 하는 것에 대해서 배웠다. 하지만, 현실에서는 사용`불가능`한 통신방식이다. 한번에 한개의 패킷만 통신이 가능해서 인터넷 속도가 `매우 느려`질 것이다. 

현실세계에서는 `파이프라인 형식`으로 한번에 `많은 패킷`을 보내고 받는 그런 방식을 사용한다. 그럼으로써 `시퀀스넘버의 복잡성`이 증가할 것이고, `피드백 방식의 복잡성`도 높아질것이다. 

다음시간에 이것에 대해서 알아보자.
