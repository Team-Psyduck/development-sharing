# 전송계층1

transport 계층에서 가장 중요한 개념중 하나인

Reliable 서비스를 하기 위한 기본 원리 

언더라인 채널 자체가 unreliable하기 때문에 발생하는 패킷에러 패킷 로스를 극복하기 위한 메카니즘들의 집합 

패킷 에러 

피드백 

재전송 

시퀀스 넘버 패킷을 구분하게 해주는 장치 

패킷 로스 

타이머를 사용 

패킷의 대한 피드백이 오지 않으면 유실이라고 판단. 

파이프라인 프로토콜의 두가지 일반적인 형식 

1. go-Back-N
2. selective repeat

 

### Go-Back_N

**얼마만큼 많이 보낼것이냐?**

**window 개념** 

window size로 이 사이즈 만큼은 패킷을 한번에 보낼 수 있다. (패킷의 갯수를 정의한다)

**피드백은 어떻게 하느냐?**

이전 Reliable data protocal에서는 ACK를 통해서 응답을 확인했다. 

파이프라인 프로토콜도 동일하다. 하지만, 패킷을 1개씩 전달하는것이 아니기 때문에 ACK11 이렇게 응답을 한다.(11번까지 잘받았으니 12번을 보내줘)

**타이머는 어떻게 작동하는가?**

만약 4개의 패킷을 전송하는데 처음 보낸 패킷의 타이머가 터졌다면, 처음 보낸 패킷만 재전송하는것이 아니라 4개 모두 다시 재전송한다. 

**receiver는 어떻게 동작하는가** 

sender가 1,2,3을 순서대로 줘야 하는데 만약 1,3,2 이렇게 전달을 해준다면, receiver는 1번을 받고 ack1을 전달, 받아야할 패킷 번호 2번으로 수정한다. 하지만,3번이 왔고 자신이 받아야할 패킷 번호와 다르기때문에 전달 받은 3번 패킷을 버린다. 그리고 ack1을 전달, 그뒤 2번이 온다면 ack2을 전달 후 받아야할 패킷넘버 3을 전달해준다. (ack는 마지막으로 전달받은 패킷의 번호와 같다)

하지만, 이미 3번 패핏을 통신하는 과정중에서 버리게 되었으므로 누락이 발생하여 sender는 다시 1번 패킷부터 재전송을 하게 되다.

********전체적인 흐름********

0부터 10까지의 패킷이 존재하고 윈도우 사이즈는 3이라고 할때, 0~2번 패킷을 전송하고 receiver는 0번 ack를 보낸다. 그리고 sender는 4번 패킷을 전송, receiver는 1번 ack를 보낸다. 

그러다가 중간에 5번 패킷을 보냈는데 receiver가 받지 못하였고 4번 ack를 전달하여 재전송을 요청한다. 그러면 sender는 응답을 받지 못하였으니 타임아웃 처리를 하여 윈도우 안에 있는 모든 패킷을 다시 재전송한다. 

(5번 패킷만 전달을 못받았지만, 5~7번패킷을 재전송하는것이다.)

### selective repeat

Go-Back-N과 다르게 selective repeat는 유실된 패킷을 전송받을때 윈도우 안에 있는 모든 패킷을 재전송 받는 것이 아니라 유실된 해당 패킷만 재전송 받은다음 이미 제대로 받은 패킷들은 건너띄고 앞으로 받을 패킷을 전송 받게 된다. 

그러므로 아무일도 안하던 Go-Back-N의 receiver와는 다르게 selective repaet는 일을 좀 한다. 

### 시퀀스 넘버

최소하의 범위를 가진 시퀀스 넘버에 대해서 생각해보자. 

윈도우 사이즈의 2배가 적절하다.
