# 전송계층3

## flow control

송신측과 수진측의 데이터처리 속도 차이를 해결하기 위한 기법이다.

flow control은 receiver-drive라고 한다. 왜냐면 receiver의 크기 만큼 sender가 보내는 크기가 정해지기 때문이다. 

receiver는 sender에게 자신의 크기를 어떻게 알려주는가 

tcp세그먼트 헤더부분에 receive buffer size라는 필드가 존재한다. 

### receive buffer에 공간이 없을 경우

만약 receiver 버퍼 공간에 여유가 없어서 0의 크기를 갖고 있다고 헤더에 전송하면 sender는 가만히 멈춰있는것이 아니라 데이터가 없는 세그먼트를 계속 전송하여 receiver의 ack를 받는다. 

ack를 계속해서 받다가 receiver의 버퍼에 공간이 생겼다는 헤더를 receiver를 통해서 알게되면 다시 데이터를 전송하게 된다. 

## TCP 3-way-handShake

클라이언트가 나의 시퀀스 넘버를 서버에게 알려준다. 

서버도 시퀀스 넘버와 확인했다는 ack를 보낸다. 

클라이언트도 서버의 시퀀스 넘버를 확인했다는 ack를 보낸다. 

## TCP 4-way-handShake

클라이언트가 종료하겠다는 fin을 서버에게 보낸다.

서버는 fin을 수신하고 확인했다는 ACK를 전달한다. 그리고 연결을 종료하겠다는 FIN을 클라이언트에게 전송한다.

클라이언트는 fin을 수신하고 확인했다는 ack를 전송한다. 

그리고 time wait 상태가 되고, time wait시간만큼 기다린 다음 서버와의 통신을 끊는다. 

**time wait**

클라이언트의 마지막 ack는 제대로 전송이 되었는지 확인하지 못하기 때문에 특정 시간동안 기다린다음 연결을 종료하는것이다. 

만약 서버가 ack를 받지 못했다면, 서버는 클라이언트에게 계속해서 fin을 재전송하기 때문에 특정시간까지 기다린다음 time-out을 방지한다. 

## 데이터 전송량 조절

데이터 전송량을 조절하는 지배자는 두가지가 있다. 

하나는 위에서 배운 flow control 다른하나는 내부의 네트워크(라우터) 상태이다. TCP는 내부 네트워크가 막혀있다(네트워크 작동 x)상태라면 매우 최악이다. time out 으로 계속해서 데이터를 전송하기 때문에 불난집에 부채질하는 격이다. 그래서 이점을 보안하기 위해서 아래의 두가지 해결 모델이 존재한다. 

### Network-assisted congestion control

네트워크가 라우터들이 현재 자신의 큐의 상태를 tcp통신하려는 곳에 전달하여 tcp가 자신의 데이터 전송량을 조절한다. 

(하지만, 현재는 라우터가 할 일(큐에 쌓인 데이터를 빨리 전송하는 일)이 많기 때문에 구현이 되어있지 않다. 

### end to end congestion control

현재 사용되는 방식이다.

통신하려는 양쪽이 내부 네트워크 상황을 유추해서 데이터 전송량을 조절한다. 

유추할 수 있는 단 하나의 키! tcp의 세그먼트이다. 

예를 들면 세그먼트를 전달했는데 응답이 안온다? 현재 라우터에 문제가 발생한 것이다. 그러므로 네트워크 상태가 안좋다고 판단하여 데이터 전송량을 조절한다. 

예를 들면 10MB를 전송했는데 ack가 늦게 온다? 데이터 전송량을 줄인다. 3MB를 전송했는데 ack가 빨리 온다? 데이터 전송량을 늘린다.
