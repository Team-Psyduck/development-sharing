## 운영체제란 무엇인가

운영체제란 컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층

- 좁은 의미의 운영체제(커널)
운영체제의 핵심 부분으로 컴퓨터가 켜질 때 부터 꺼질 때까지 메모리에 상주하는 부분
- 넓은 의미의 운영체제
커널 뿐 아니라 각종 주변 시스템 유틸리티를 포함한 개념(독립적인 실행 파일, 컴퓨터 시스템을 전반적으로 관리하는데 필요한 부분)

### 운영체제 목적

컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공

- 자원을 효율적으로 관리해준다. 
프로세서, 기억장치, 입출력 장치 등을 효율적으로 관리 
주어진 자원을 최대한의 성능을 내도록 한다.
- 사용자 및 운영체제 자신의 보호
- 프로세스, 파일, 메세지 등을 관리한다.

(컴퓨터의 뇌는 운영체제이다. CPU도 두뇌라고 하지만, CPU는 계산만을 한다. 하지만, 운영체제는 관리하는 능력을 갖고 있기 때문에 운영체제가 컴퓨터의 뇌이다.)

### 하는 일

메모리 공간을 어떻게 분배해 줄 것인가?

CPU를 어떻게 효율적으로 사용하게 해 줄 것인가?

### 분류

운영체제는 3가지로 분류가 가능하다. 

- **동시 작업 가능 여부**
    - 단일 작업
        - 한 번에 하나의 작업만 처리한다.
        - 예) MS-DOS 프롬프트 상에서는 한 명령의 수행을 끝내기 전에 다른 명령을 수행시킬 수 없음(현재는 없어진 방식)
    - 다중 작업
        - 동시에 두 개 이상의 작업 처리 (사실 작업은 하나씩 진행하지만, 시분할 방식으로 동시에 두개 이상의 작업을 진행하는 것처럼 보인다)
        - 예) UNIX, MS Windows 등에서는 한 명령의 수행이 끝나기 전에 다른 명령이나 프로그램을 수행할 수 있음
- **사용자의 수**
    - 단일 사용자
        - 예) MS-DOS, MS Windows
    - 다중 사용자
        - 예) UNIX(Linux), NT server
- **처리 방식**
    - 일괄 처리 (batch processing)
        - 작업 요청의 일정량 모아서 한꺼번에 처리
        - 작업이 완전 종료될 때까지 기다려야 한다.
        - 현재는 진행하지 않는 방식이다.
    - 시분할(time sharing)
        - 여러 작업을 수행할 때 컴퓨터 처리 능력을 일정한 시간 단위로 분할하여 사용
        - 일괄 처리 시스템에 비해 짧은 응답 시간을 가진다.(예시,Unix)
        - interactive 방식 (batch에 반대되는 말)
        - 현재 대중적으로 사용중인 방식이다.
    - 실시간(Realtime OS)
        - 정해진 시간 안에 어떠한 일이 반드시 종료됨이 보장되어야 하는 실시간 시스템을 위한 OS
        - 원자로/공장 제어, 미사일 제어, 반도체 장비 등
        - Hard realtime system
        - Soft realtime system

## 용어

**multi tasking** : 프로그램을 여러개 돌리는 것 

**multiProgramming** : 메모리에 여러 프로그램이 동시에 올라가 있는 것 

**Time sharing** : CPU의 시간을 분할하여 나누어 쓴다는 의미를 강조하는 것 

**Multiprocess** : 여러개의 프로세스를 실행하는 것 

**Multiprocessor** : 하나의 컴퓨터에 CPU가 여러 개 붙어 있음을 의미한다. → 동시에 여러 프로그램들이 서로다른 CPU에서 일을 할 수 있게 된다. 하지만, 여러 CPU에서 하나의 메모리를 동시에 같이 사용하다보면 발생하는 문제점들이 있다. 

## 운영체제 예

### 유닉스(UNIX)

- 코드의 대부분을 C언어로 작성
- 높은 이식성
- 최소한의 커널 구조
- 복잡한 시스템에 맞게 확장 용이
- 소스 코드 공개
- **프로그램 개발에 용이**
- 다양한 버전
    - System V, FreeBSD, SunOS, Solaris
    - LInux

### DOS(Disk Perating System)

- MS사에서 개인용 컴퓨터를 위해 단일 사용자용 운영체제를 개발
- 메모리 관리 능력의 한계(주 기억 장치 : 640KB)

### MS Windows

- MS사의 다중 작업용 GUI기반 운영 체제
- Plug and Play 네트워크 환경 강화
- DOS용 응용 프로그램과 호환성 제공
- 불안정성
- 풍부한 지원 소프트웨어

### Handheld device를 위한 OS(핸드폰)

- PalmOS, Pocket PC (WinCE), Tiny OS, Android, iOS

## 컴퓨터 시스템 구조

<img width="502" alt="스크린샷 2023-06-13 오후 9 01 51" src="https://github.com/SionBackEnd/tech-sharing/assets/104377048/30f68dcc-40f0-4f3e-8d1c-dc6ec0b77d12">


**CPU** : 작업을 처리하는 장치

**Memory** : CPU의 작업 공간 

**device controller** : 해당 device들의 관리자이다. (장치 CPU라고 이해하면 편하다)

**local buffer** : 각각의 device의 작업  공간(작은 메모리)

**Mode bit : 운영체제의 명령인지, 사용자 프로그램의 명령인지 구분하는 장치**

사용자 프로그램이 CPU를 점유하면 운영체제가 CPU 제어권을 가져올 수 없기 때문에 Mode bit을 통해 운영체제 권한을 사용할 수 없게 만든다. (운영체제 권한 기계어를 실행하려면 자동으로 운영체제에게 CPU권한이 넘어간다. (Interrupt / Exception을 통해 권한을 가져온다.)

- Mode bit을 통해 하드웨어적으로 두 가지 모드의 operation을 지원한다. 
1 : 사용자 모드 → 사용자 프로그램 수행
0 : 모니터 모드 → OS코드 수행
- 보안을 해칠 수 있는 중요한 명령어는 모니터 모드에서만 수행 가능한 “특권명령”으로 규정한다.
- Interrupt나 Exception 발생시 하드웨어가 mode bit을 0으로 변경한다.
- 사용자 프로그램에게 CPU를 넘기기 전에 mode bit을 1로 셋팅한다.

*모니터 모드 = 커널 모드, 시스템 모드

<aside>
💡 **Mode bit이 존재해야 하는 이유** 
혹여나 사용자 프로그램이 악성 프로그램일 때 CPU가 해당 프로그램의 작업을 진행한다면 운영체제는 그 작업에 대해서 관여할 수 없다. 
설령 관여하려해도 결국 CPU의 작업권한을 얻어야 하며, 운영체제의 기계어를 실행주어야 하는데 이미 악성 프로그램의 기계어를 실행하였기 때문에 막을 수 없다. 

Mode bit으로 해당 작업을 1 또는 0으로 구분하여 운영체제 작업인지, 사용자 프로그램 작업인지 구분하는 것은 매우 중요하다.

</aside>

**인터럽트** 

CPU 사용 제어권을 운영체제에게 넘기는 것이다. (인터럽트 당한 시점의 레지스터와 PC를 저장)

넓은 의미  : 하드웨어가 발생시킨 인터럽트 (I/O)

좁은 의미 : Trap이라고 하며, 소프트웨어가 발생시킨 인터럽트 (Exception(timer interrupt), System call)

**Timer interrupt** 

일정시간이 흐르면 타이머가 CPU에게 인터럽트를 걸어 운영체제에게 제어권이 넘어가도록 인터럽트를 발생 시킨다. CPU 독점을 막기 위한 것이다. 

**CPU 흐름** 

CPU는 매 순간 기계어를 실행 후 Interrupt Line에 Interrupt가 존재하는 지 확인한다. 존재한다면 다음 ProgramCounter는 운영체제 위치로 변경된다. mode bit 0으로 변경 → 운영체제가 CPU를 다른 프로그램에게 넘길 때는 mode bit을 1로 변경하고 전달한다. 

**시스템 콜**

I/O 작업 요청은 전부 특권 명령이다. 
사용자 프로그램은 I/O요청 불가 → 운영체제에게 해달라고 요청해야 하는데 그 요청을 시스템 콜이라고 부른다. (제어권을 넘기기 위해서는 사용자 프로그램이 인터럽트를 고의로 발생시킨다.)

사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것 

## 동기 비동기 입출력

I/O 요청 후 해당 프로그램이 계속 작업을 진행 할 수 있냐 없냐로 나눌 수 있다. 

**동기식 입출력 (synchronous I/O)**

A 프로그램이 I/O 요청을 했다면, CPU 제어권을 빼앗고 다음 CPU 제어권을 원하는 프로그램에게 권한을 넘겨준다. I/O 작업이 완료 되었다는 인터럽트 발생시 A 프로그램이 CPU 제어권을 다시 획득하고 작업을 진행한다. 

**비동기식 입출력 (asynchronous I/O)**

A 프로그램이 I/O 요청을 했다면, CPU 제어권을 빼앗지 않고, A 프로그램에서 다음 실행할 명령어를 실행한다. 
I/O 작업이 완료 되었다는 인터럽트 발생시 A 프로그램이 계속해서 CPU 작업한다. (timer interrupt 발생 시 제어권을 뺏긴다.)

## DMA Controller

인터럽트 자체도 오버헤드가 발생한다. 
매번 입출력 때문에 인터럽트가 발생하면 오버헤드가 발생하니 devise controller가 memory에 접근 할 수 있도록 하는 것이다. 

memory를 사용하는 곳은 CPU밖에 없지만, DMA를 사용하면, CPU의 개입없이 devise controller가 memroy에 block 단위로 직접 전송할 수 있게 된다. (바이트 단위 인터럽트가 아니라, block 단위로 인터럽트가 발생한다.)
