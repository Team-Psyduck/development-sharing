### 프로그램 실행 단계
실행 파일을 실행 시키면 Virtual Memroy(독자적인 주소 공간) 생기고 VM에서 당장 실행해야 할 것들은 피지컬 메모리에 올라간다.  
VM과 피지컬 메모리 사이에 메모리 주소가 다르기 때문에 Address translation 작업을 진행 후 피지컬 메모리에 적제 된다.   

### 메모리 내부
Stack : 함수 내부 변수, 함수 호출, 리턴 값 들이 저장된다.  
data : 전역변수 (프로그램이 시작부터 끝까지 존재하는 변수)들이 저장된다.  
code : CPU에서 실행될 기계어가 담겨있다.  

### 커널 내부
stack : 각 프로세스들의 별도 커널 스택을 갖고 있다. (Process A의 커널 스택, Process B의 커널 스택)  
data : PCB, CPU, MEmory, Disk가 저장되어 있다.   
code : 시스템콜과 인터럽트 처리코드, 자원관리를 위한 코드, 편리한 서비스 제공을 위한 코드  

### 함수 
사용자 정의 함수 : 자신의 프로그램에서 정의한 함수  
라이브러리 함수 : 자신의 프로그램에서 정의하지 않고 갖다 쓴 함수, 자신의 프로그램의 실행 파일에 포함되어 있다.  
커널 함수 : 운영체제 프로그램의 함수, 커널 함수의 호출 = 시스템 콜   

### 프로그램 실행 흐름
A 프로그램이 실행된다고 가정하자  
A프로그램의 작업을 유저모드에서 자신의 함수를 사용해서 작업하다가 시스템 콜을 해서 커널모드로 변환한다.   
운영체제가 넘겨받고 운영체제 함수를 통해 작업을 하다가 완료하면 유저모드로 변환해 준다. 이렇게 반복하다가   
프로그램이 종료된다.  

### 프로세스
프로세스의 문맥  
CPU 수행 상태를 나타내는 하드웨어 문맥 : Program Counter, 각종 register  
프로세스의 주소 공간 : code, data, stack  
프로세스 관련 커널 자료 구조  : PCB(Process Control Block), Kernel stack  

### 프로세스의 상태
Running : CPU를 통해 작업을 진행 중인 프로세스  
Ready : CPU 사용을 기다리고 있는 프로세스  
blocked(wait, sleep) : 프로세스 자신이 요청한 I/O작업이 즉시 만족되지 않아 기다리는 상태 (Disk에서 file을 읽어와야 하는 경우)  
new : 프로세스가 생성 중인 상태  
Terminated : 프로세스가 종료 중인 상태   


### PCB
운영체제가 각 프로세스를 관리하기 위해 프로세스당 유지하는 정보  
커널 메모리 data 영역에 존재한다. 각 프로세스당 하나의 PCB를 갖게 된다.   

구조  
OS가 관리상 사용하는 정보 : 우선순위나 스케줄링 정보  
CPU 수행 관련 정보 : PC, register  
메모리 관련 : code, data, stack   
파일 관련 : open file descriptors (어떤 파일을 열어서 사용하고 있는지)  

### 문맥 교환 Context Switch
문맥 교환은 사용자 프로세스 A에서 사용자 프로세스 B로 넘어가는 상황을 문맥 교환이라고 한다.   
문백 교환이 일어나면 A 프로세스의 작업 정보를 A PCB에 저장하고, 앞으로 작업할 B 프로세스의 이전 작업 정보를  
B PCB에서 불러오는 작업을 한다. 이것이 문맥 교환이다.   

예시  
사용자 프로세스 A -> 시스템콜 -> 커널 모드 -> 유저 모드 변환 -> 사용자 프로세스 A   
문맥 교환이 일어나지 않은 상태  
사용자 프로세스 A -> 타이머 인터럽트 발생 -> 커널 모드 -> 유저 모드 변환 -> 사용자 프로세스 B  
문맥 교환이 일어난 상태   

1번 경우에도 CPU 수행 정보 등 context의 일부를 PCB에 저장해야 하지만, 문맥 교환을 하는 2번에 경우에는 그 부담이 훨씬 크다. (chace memory, flush)

### 운영체제의 프로세스 스케줄링 큐 
프로세스들은 각 큐들을 오가며 수행된다.  

Job queue : 현재 시스템 내에 잇는 모든 프로세스의 집합  
Ready queue : 현재 메모리 내에 있으면서 CPU를 잡아 실행되기를 기다리는 프로세스의 집합  
Device queues : I/O device의 처리를 기다리는 프로세스의 집합  

### 스케줄러
스케줄러는 총 3가지로 나눌 수 있다. 스케줄링은 운영체제 함수가 해주는 일이다.  
Long-term scheduler (장기 스케줄러 or job scheduler)  
- 현재의 운영체제 time sharing system에는 보통 장기 스케줄러가 없다. (무조건 프로세스가 new 상태에서 ready상태로 바로 변경된다.)
- 이전에 운영체제에서 사용하던 방식이며, new 상태인 프로세스들 중 어떤것을 ready 상태로 변경할 지 결정
short-term scheduler (단기 스케줄러 or CPU scheduler)   
- 어떤 프로세스를 다음번에 running 상태로 변경 시킬지 결정 (timer interrput 발생 시)
- 프로세스에 CPU를 주는 문제 
- 충분히 빨라야 한다.(millisecond 단위) 
Medium-term Scheduler (중기 스케줄러 or Swapper)  
- 여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫒아냄 
- 프로세스에게서 memory를 뺏는 문제 
- degree of Miltiprogramming을 제어 

### Medium-term Scheduler에 의한 프로세스 상태 변화
Suspended(stopped) : 메모리에서 쫒겨난 상태  
외부적인 이유로 프로세스의 수행이 정지된 상태  
프로세스는 통째로 디스크에 swap out 된다.   
예시 ) 사용자가 프로그램을 일시 정지시킨 경우(break key)  
시스템이 여러 이유로 프로세스를 잠시 중단시킴 (메모리에 너무 많은 프로세스가 올라와 있을 때  

### Thread 
CPU 실행 단위를 Thread라고 한다.   
### Thread 구성 
- program counter
- register set
- stack space
### 한 프로세스 안에서 Thread가 동료 THread와 공유하는 부분
- code section
- data section
- OS resources

Thread 특징
- 응답성이 빠르다. 
- 자원을 공유할 수 있다. 
- 프로세스 하나를 만드는 것 보다, 스레드 하나를 만드는 것이 30배 이상 더 효율이 좋다. 
- 멀티코어 환경에서 스레드를 병렬적으로 작업할 수 있다.

### 커널 스레드, 유저 스레드
운영체제는 커널 스레드만을 알고 있고, 유저 스레드는 알지 못한다. 커널 스레드는 유저 스레드를 몰라서 그저 하나의 프로세스로 보인다.   

### 프로세스 생성
부모 프로세스가 자식 프로세스를 생성한다. (부모가 자식을 만들면 부모와 동일한 프로세스로 만들어진다.)  
부모 프로세스가 자식 프로세스를 직접 만들 수 없기 떄문에 운영체제가 만들어 달라고 부탁해야 한다. 그때 사용하는  
메서드는 fork() 시스템 콜 함수를 이용한다. 
프로세스의 트리(계층 구조) 형성 
프로세는 자원을 필요로 함 
- 운영체제에게 받는 방법
- 부모와 공유하는 방법 (이례적인 경우이다.)

자원의 공유
- 부모와 자식이 모든 자원을 공유하는 모델
- 일부를 공유하는 모델
- 전형 공유하지 않는 모델 
- 부모와 자식은 공존하며 수행되는 모델 
- 자식이 종료될 때까지 부모가 기다리는 모델

자식은 부모의 공간을 복사해서 code, data, stack 모든 것들을 복사하고 부모가 지니고 있던 pc의 위치에서 작업이 시작된다. 

### 프로세스 종료
프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려준다. (exit)  
- 자식이 부모에게 output data 를 보낸다.   
- 프로세스는 각종 자원들이 운영체제에게 반남된다.   

부모 프로세스가 자식의 수행을 강제로 종료시킨다.(abort)  

자식이 할당 자원의 한계치를 넘어선 경우  
자식에게 할당된 태스크가 더 이상 필요하지 않는다.   

부모가 종료(exit)하는 경우    
- 프로세스 세계에서는 부모가 먼저 죽는 것이 아니라 자식 먼저 죽어야 부모가 죽을 수 있다.   
- 단계적인 종료   


### fork() 시스템 콜
fork를 하게 되면, fork() 함수가 불린 순가 부모 프로세스와 완전히 동일한 자식 프로세스가 하나 생성되고, 부모프로세스가 fork()함수 이후 실행한 로직을 자식 프로세스도 동일하게 실행한다.   
또한 둘은 완전히 동일하기 때문에 어떤 프로세스가 부모인지 모른다. 이것을 구분하기 위해서 pid를 다르게 배정받게 된다. 부모 프로세스라면 자식 프로세스의 pid를 배정받고, 자식 프로세스는 pid 값 0을 받게 된다.   
따라서 PID값에 따라서 복제된 자식이 다른 로직을 수행할 수 있게 구분할 수 있다.  

### exec() 시스템 콜
exec() 함수같은 경우에는 아예 다른 프로그램을 띄우게 해주는 함수이다.  
주로 fork()와 함께 사용하는데, fork()한 자식프로세스는 exec()함수를 실행하여 다른 프로그램을 실행하게 만들고 기존 부모 프로세스는 자신의 프로그램을 계속 실행하게 하는 방식으로 사용한다.  






